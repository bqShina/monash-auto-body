{"version":3,"file":"react-mark-image.cjs.production.min.js","sources":["../src/types/index.ts","../src/utils/compose.ts","../src/utils/offsetCoordinates.ts","../src/components/TextEditor/index.tsx","../src/components/Editor/index.tsx","../src/hocs/SelectorUtils.ts","../src/hocs/RectangleSelector.ts","../src/hocs/PointSelector.ts","../src/hocs/OvalSelector.ts","../src/components/Content/index.tsx","../src/components/Overlay/index.tsx","../src/components/Shapes/withShapeWrapper.tsx","../src/components/Shapes/Oval.tsx","../src/components/Shapes/Point.tsx","../src/components/Shapes/Rectangle.tsx","../src/components/defaultProps.tsx","../src/components/Image/index.tsx","../src/components/ToolBar/ToolBar.tsx","../src/utils/withRelativeMousePos.tsx","../src/components/Annotation.tsx","../src/utils/useHandleEscapeEvent.ts"],"sourcesContent":["import {\n  ReactElement,\n  MouseEvent,\n  MouseEventHandler,\n  TouchEvent,\n  CSSProperties,\n} from 'react';\n\nexport interface IPoint {\n  x: number;\n  y: number;\n}\n\nexport interface IContainer {\n  height: number;\n  width: number;\n}\n\nexport interface SelectorMethodsOptions {\n  editorMode: EditorMode;\n  idFunction: () => string;\n}\nexport interface ISelectorMethods {\n  onMouseDown?: (\n    annotation: IAnnotation | undefined,\n    e: MouseEvent,\n    options: SelectorMethodsOptions\n  ) => IAnnotation | undefined;\n\n  onMouseUp?: (\n    annotation: IAnnotation | undefined,\n    e: MouseEvent,\n    options: SelectorMethodsOptions\n  ) => IAnnotation | undefined;\n\n  onMouseMove?: (\n    annotation: IAnnotation | undefined,\n    e: MouseEvent,\n    options: SelectorMethodsOptions\n  ) => IAnnotation | undefined;\n\n  onTouchStart?: (\n    annotation: IAnnotation | undefined,\n    e: TouchEvent,\n    options: SelectorMethodsOptions\n  ) => IAnnotation | undefined;\n\n  onTouchEnd?: (\n    annotation: IAnnotation | undefined,\n    e: TouchEvent,\n    options: SelectorMethodsOptions\n  ) => IAnnotation | undefined;\n\n  onTouchMove?: (\n    annotation: IAnnotation | undefined,\n    e: TouchEvent,\n    options: SelectorMethodsOptions\n  ) => IAnnotation | undefined;\n\n  onClick?: (\n    annotation: IAnnotation | undefined,\n    e: any,\n    options: SelectorMethodsOptions\n  ) => IAnnotation | undefined;\n}\n\nexport interface ISelector {\n  TYPE: AllowedShape;\n  intersects: (\n    { x, y }: { x: number; y: number },\n    geometry: IGeometry,\n    container: { width: number; height: number }\n  ) => boolean;\n  area: (\n    geometry: IGeometry,\n    container: { width: number; height: number }\n  ) => number;\n  methods: ISelectorMethods;\n}\n\ninterface AnnotationData extends Record<string, any> {\n  text?: string;\n  id: string;\n}\n\nexport interface IGeometry {\n  type: string;\n  x: number;\n  y: number;\n  height: number;\n  width: number;\n}\n\nexport interface IAnnotation {\n  selection?: {\n    mode: string;\n    anchorX?: number | null;\n    anchorY?: number | null;\n  };\n  geometry: IGeometry;\n  data: AnnotationData;\n}\n\nexport interface RenderEditorProps {\n  annotation: IAnnotation;\n  onSubmit: (e: IAnnotation) => void;\n}\n\nexport interface ShapeProps {\n  annotation: IAnnotation;\n  children?: ReactElement | null;\n  editorMode: EditorMode;\n  isMouseOver: boolean;\n  isSelected: boolean;\n  onMouseEnter: MouseEventHandler<HTMLDivElement>;\n  onMouseLeave: MouseEventHandler<HTMLDivElement>;\n  style?: CSSProperties;\n}\n\nexport interface RenderShapeProps {\n  annotation: IAnnotation;\n  editorMode: EditorMode;\n  key: string;\n  isInSelectionMode: boolean;\n  onAnnotationClick: (annotation: IAnnotation) => void;\n  renderContent?: (props: ContentProps) => ReactElement | null;\n  selectedAnnotation?: IAnnotation;\n}\n\nexport interface ContentProps {\n  key?: string;\n  annotation: IAnnotation;\n}\n\nexport interface RenderSelectorProps {\n  isInSelectionMode: boolean;\n  annotation: IAnnotation;\n  renderContent?: (props: ContentProps) => ReactElement | null;\n}\n\nexport enum EditorMode {\n  AnnotateWithText = 'AnnotateWithText',\n  AnnotateOnly = 'AnnotateOnly',\n  ReadOnlyWithSelection = 'ReadOnlyWithSelection',\n  ReadOnly = 'ReadOnly',\n}\n\nexport enum SelectionMode {\n  New = 'NEW',\n  Selecting = 'SELECTING',\n  Editing = 'EDITING',\n  Final = 'FINAL',\n}\n\nexport type WrappedShapeProps = {\n  annotation: IAnnotation;\n  children?: ReactElement | null;\n  editorMode: EditorMode;\n  isInSelectionMode: boolean;\n  key: string;\n  onAnnotationClick: (annotation: IAnnotation) => void;\n  renderContent?: (props: ContentProps) => ReactElement | null;\n  selectedAnnotation?: IAnnotation;\n  style?: CSSProperties;\n};\n\nexport interface RenderOverlayProps {\n  annotations: IAnnotation[];\n  overlayText?: string;\n  selectorType: string;\n}\n\nexport enum AllowedShape {\n  Oval = 'Oval',\n  Point = 'Point',\n  Rectangle = 'Rectangle',\n}\n\nexport interface RenderToolbarProps {\n  allowedShapes: AllowedShape[];\n  deleteAnnotation: (annotation: IAnnotation) => void;\n  options: ToolBarOptions;\n  selectedAnnotation: IAnnotation | undefined;\n  selectedSelectorType: string;\n  setSelectedSelectorType: (selector: AllowedShape) => void;\n  unSelectSelectedAnnotation: (annotation: IAnnotation) => void;\n}\n\nexport interface RenderSelectedAnnotationIconsProps {\n  annotation: IAnnotation;\n  unSelectAnnotation: () => void;\n}\n\nexport interface ToolBarOptions {\n  showToolBar?: boolean;\n  showDeleteOption?: boolean;\n  renderToolbarIcons?: () => ReactElement | null;\n  renderSelectedAnnotationIcons?: (\n    props: RenderSelectedAnnotationIconsProps\n  ) => ReactElement | null;\n}\n\nexport interface OverlayOptions {\n  displayOverlay?: boolean;\n  overlayText?: string;\n}\n\nexport interface AnnotationProps {\n  src: string;\n  alt?: string;\n  allowedShapes: AllowedShape[];\n\n  annotations: IAnnotation[];\n\n  children?: any;\n  className?: string;\n\n  editorMode: EditorMode;\n\n  idFunction: () => string;\n\n  onAnnotationsUpdate: (annotations: IAnnotation[]) => void;\n  onAnnotationClick: (annotation: IAnnotation) => void;\n  onSelectedAnnotationUpdate: (\n    annotation: IAnnotation,\n    selected: boolean\n  ) => void;\n\n  overlayOptions?: OverlayOptions;\n\n  renderContent: (props: ContentProps) => ReactElement | null;\n  renderEditor: (props: RenderEditorProps) => ReactElement | null;\n  renderShape: (props: WrappedShapeProps) => ReactElement | null;\n  renderOverlay: (props: RenderOverlayProps) => ReactElement | null;\n\n  selectors: ISelector[];\n  style?: object;\n\n  toolBarOptions: ToolBarOptions;\n}\n","export default function compose(...funcs: Function[]) {\n  if (funcs.length === 0) {\n    return (arg: any) => arg;\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce(\n    (a, b) =>\n      (...args: any[]) =>\n        a(b(...args))\n  );\n}\n","import { MouseEvent, TouchEvent } from 'react';\n\nconst getMouseRelativeCoordinates = (e: MouseEvent) => {\n  // nativeEvent.offsetX gives inconsistent results when dragging\n  // up and to the left rather than the more natural down and to the\n  // right. The reason could be browser implementation (it is still experimental)\n  // or it could be that nativeEvent offsets are based on target rather than\n  // currentTarget.\n  // To keep consistent behavior of the selector use the bounding client rect.\n  const rect = e.currentTarget.getBoundingClientRect();\n  const offsetX = e.clientX - rect.x;\n  const offsetY = e.clientY - rect.y;\n\n  return {\n    x: (offsetX / rect.width) * 100,\n    y: (offsetY / rect.height) * 100,\n  };\n};\n\nconst clamp = (a: number, b: number, i: number) => Math.max(a, Math.min(b, i));\n\nconst getTouchRelativeCoordinates = (\n  e: TouchEvent\n): { x: number; y: number } => {\n  const touch = e.targetTouches[0];\n\n  const boundingRect = e.currentTarget.getBoundingClientRect();\n  // https://idiallo.com/javascript/element-postion\n  // https://stackoverflow.com/questions/25630035/javascript-getboundingclientrect-changes-while-scrolling\n  const offsetX = touch.pageX - boundingRect.left;\n  const offsetY = touch.pageY - (boundingRect.top + window.scrollY);\n\n  return {\n    x: clamp(0, 100, (offsetX / boundingRect.width) * 100),\n    y: clamp(0, 100, (offsetY / boundingRect.height) * 100),\n  };\n};\n\nconst getCoordPercentage = (\n  e: MouseEvent | TouchEvent\n): { x: number; y: number } | undefined => {\n  if (isTouchEvent(e)) {\n    if (isValidTouchEvent(e)) {\n      isTouchMoveEvent(e) && e.preventDefault();\n      return getTouchRelativeCoordinates(e as TouchEvent);\n    }\n    return;\n  } else {\n    return getMouseRelativeCoordinates(e as MouseEvent);\n  }\n};\n\nconst isTouchEvent = (e: any) => e.targetTouches !== undefined;\nconst isValidTouchEvent = (e: any) => e.targetTouches.length === 1;\nconst isTouchMoveEvent = (e: any) => e.type === 'touchmove';\n\nexport {\n  getMouseRelativeCoordinates as getOffsetCoordPercentage,\n  getCoordPercentage,\n};\n","import styled from 'styled-components';\nimport React, { ChangeEvent, FocusEvent, MouseEvent } from 'react';\n\nconst Inner = styled.div`\n  padding: 8px 16px;\n\n  textarea {\n    border: 0;\n    font-size: 14px;\n    margin: 6px 0;\n    min-height: 60px;\n    outline: 0;\n  }\n`;\n\nconst Button = styled.div`\n  background: whitesmoke;\n  border: 0;\n  box-sizing: border-box;\n  color: #363636;\n  cursor: pointer;\n  font-size: 1rem;\n  margin: 0;\n  outline: 0;\n  padding: 8px 16px;\n  text-align: center;\n  text-shadow: 0 1px 0 rgba(0, 0, 0, 0.1);\n  width: 100%;\n\n  transition: background 0.21s ease-in-out;\n\n  &:focus,\n  &:hover {\n    background: #eeeeee;\n  }\n`;\n\nexport interface TextEditorProps {\n  onBlur?: (e: FocusEvent<HTMLTextAreaElement>) => void;\n  onChange?: (e: ChangeEvent<HTMLTextAreaElement>) => void;\n  onFocus?: (e: FocusEvent<HTMLTextAreaElement>) => void;\n  onSubmit?: (e: MouseEvent<HTMLDivElement>) => void;\n  value?: string;\n}\n\nfunction TextEditor(props: TextEditorProps) {\n  return (\n    <React.Fragment>\n      <Inner>\n        <textarea\n          placeholder=\"Write description\"\n          onFocus={props.onFocus}\n          onBlur={props.onBlur}\n          onChange={props.onChange}\n          value={props.value}\n        />\n      </Inner>\n      {props.value && <Button onClick={props.onSubmit}>Submit</Button>}\n    </React.Fragment>\n  );\n}\n\nexport default TextEditor;\n","import React, { ChangeEvent, useState } from 'react';\nimport styled, { keyframes } from 'styled-components';\nimport TextEditor from '../TextEditor';\nimport { IAnnotation } from '../../types/index';\n\nconst fadeInScale = keyframes`\n  from {\n    opacity: 0;\n    transform: scale(0);\n  }\n\n  to {\n    opacity: 1;\n    transform: scale(1);\n  }\n`;\n\nconst Container = styled.div`\n  background: white;\n  border-radius: 2px;\n  box-shadow: 0 1px 5px 0 rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14),\n    0 3px 1px -2px rgba(0, 0, 0, 0.12);\n  margin-top: 16px;\n  transform-origin: top left;\n\n  animation: ${fadeInScale} 0.31s cubic-bezier(0.175, 0.885, 0.32, 1.275);\n  overflow: hidden;\n  z-index: 2;\n`;\n\ninterface EditorProps {\n  annotation: IAnnotation;\n  className?: string;\n  onSubmit: (e: IAnnotation) => void;\n  style?: object;\n}\n\nfunction Editor(props: EditorProps) {\n  const { geometry } = props.annotation;\n  const [text, setText] = useState('');\n\n  if (!geometry) return null;\n\n  return (\n    <Container\n      className={props.className}\n      style={{\n        position: 'absolute',\n        left: `${geometry.x}%`,\n        top: `${geometry.y + geometry.height}%`,\n        ...props.style,\n      }}\n    >\n      <TextEditor\n        onChange={(e: ChangeEvent<HTMLTextAreaElement>) =>\n          setText(e.target.value)\n        }\n        onSubmit={() => {\n          props.onSubmit({\n            ...props.annotation,\n            data: {\n              ...props.annotation.data,\n              text,\n            },\n          });\n        }}\n        value={text}\n      />\n    </Container>\n  );\n}\n\nexport default Editor;\n","import { MouseEvent, TouchEvent } from 'react';\nimport {\n  EditorMode,\n  IAnnotation,\n  ISelectorMethods,\n  SelectionMode,\n  SelectorMethodsOptions,\n} from '../types';\nimport { getCoordPercentage } from '../utils/offsetCoordinates';\n\nexport function pointerDown(\n  annotation: IAnnotation | undefined,\n  e: TouchEvent | MouseEvent,\n  options: SelectorMethodsOptions,\n  type: string\n): IAnnotation | undefined {\n  const selection = annotation?.selection;\n  if (!selection) {\n    const { x: anchorX, y: anchorY } = getCoordPercentage(e)!;\n\n    return {\n      geometry: {\n        x: 0,\n        y: 0,\n        type,\n        width: 0,\n        height: 0,\n      },\n      selection: {\n        mode: SelectionMode.New,\n        anchorX,\n        anchorY,\n      },\n      data: {\n        id: options.idFunction(),\n      },\n    };\n  }\n  return;\n}\n\nexport function pointerUp(\n  annotation: IAnnotation | undefined,\n  _e: TouchEvent | MouseEvent,\n  editorMode: EditorMode\n): IAnnotation | undefined {\n  if (annotation?.selection) {\n    const { geometry } = annotation;\n    if (!geometry || annotation.selection.mode === SelectionMode.New) {\n      return;\n    }\n    switch (annotation.selection.mode) {\n      case SelectionMode.Selecting:\n        return {\n          ...annotation,\n          selection: {\n            ...annotation.selection,\n            mode:\n              editorMode === EditorMode.AnnotateOnly\n                ? SelectionMode.Final\n                : SelectionMode.Editing,\n          },\n        };\n      default:\n        break;\n    }\n  }\n  return annotation;\n}\n\nexport function pointerMove(\n  annotation: IAnnotation | undefined,\n  e: TouchEvent | MouseEvent\n): IAnnotation | undefined {\n  if (\n    annotation?.selection?.mode === SelectionMode.New ||\n    annotation?.selection?.mode === SelectionMode.Selecting\n  ) {\n    const { anchorX, anchorY } = annotation.selection;\n    const { x: newX, y: newY } = getCoordPercentage(e)!;\n    const width = newX! - anchorX!;\n    const height = newY! - anchorY!;\n\n    const x = width > 0 ? anchorX : newX;\n    const y = height > 0 ? anchorY : newY;\n    return {\n      ...annotation,\n      selection: {\n        ...annotation?.selection,\n        mode: SelectionMode.Selecting,\n      },\n      geometry: {\n        ...annotation.geometry,\n        // Fix types so that these defaults are not needed\n        x: x ?? 0,\n        y: y ?? 0,\n        width: Math.abs(width),\n        height: Math.abs(height),\n      },\n    };\n  }\n  return annotation;\n}\n\nexport const createSelectorMethods = (type: string): ISelectorMethods => ({\n  onMouseDown(\n    annotation: IAnnotation | undefined,\n    e: MouseEvent,\n    options: SelectorMethodsOptions\n  ): IAnnotation | undefined {\n    return pointerDown(annotation, e, options, type);\n  },\n\n  onMouseUp(\n    annotation: IAnnotation | undefined,\n    e: MouseEvent,\n    { editorMode }: SelectorMethodsOptions\n  ): IAnnotation | undefined {\n    return pointerUp(annotation, e, editorMode);\n  },\n\n  onMouseMove(\n    annotation: IAnnotation | undefined,\n    e: MouseEvent\n  ): IAnnotation | undefined {\n    return pointerMove(annotation, e);\n  },\n\n  onTouchStart(\n    annotation: IAnnotation | undefined,\n    e: TouchEvent,\n    options: SelectorMethodsOptions\n  ): IAnnotation | undefined {\n    return pointerDown(annotation, e, options, type);\n  },\n\n  onTouchEnd(\n    annotation: IAnnotation | undefined,\n    e: TouchEvent,\n    { editorMode }: SelectorMethodsOptions\n  ): IAnnotation | undefined {\n    return pointerUp(annotation, e, editorMode);\n  },\n\n  onTouchMove(\n    annotation: IAnnotation | undefined,\n    e: TouchEvent\n  ): IAnnotation | undefined {\n    return pointerMove(annotation, e);\n  },\n});\n","import {\n  AllowedShape,\n  IGeometry,\n  IPoint,\n  ISelector,\n  ISelectorMethods,\n} from '../types/index';\nimport { createSelectorMethods } from './SelectorUtils';\n\nexport const TYPE = AllowedShape.Rectangle;\n\nexport function intersects({ x, y }: IPoint, geometry: IGeometry) {\n  if (x < geometry.x) return false;\n  if (y < geometry.y) return false;\n  if (x > geometry.x + geometry.width) return false;\n  if (y > geometry.y + geometry.height) return false;\n\n  return true;\n}\n\nexport function area(geometry: IGeometry) {\n  return geometry.height * geometry.width;\n}\n\nexport const methods: ISelectorMethods = createSelectorMethods(TYPE);\n\nconst RectangleSelector: ISelector = {\n  TYPE,\n  intersects,\n  area,\n  methods,\n};\n\nexport default RectangleSelector;\n","import { MouseEvent, TouchEvent } from 'react';\nimport {\n  AllowedShape,\n  IAnnotation,\n  IContainer,\n  IGeometry,\n  IPoint,\n  ISelector,\n  ISelectorMethods,\n  SelectionMode,\n  SelectorMethodsOptions,\n} from '../types/index';\nimport { getCoordPercentage } from '../utils/offsetCoordinates';\n\nconst MARGIN = 6;\n\nconst marginToPercentage = (container: IContainer) => ({\n  marginX: (MARGIN / container.width) * 100,\n  marginY: (MARGIN / container.height) * 100,\n});\n\nexport const TYPE = AllowedShape.Point;\n\nexport function intersects(\n  { x, y }: IPoint,\n  geometry: IGeometry,\n  container: IContainer\n) {\n  const { marginX, marginY } = marginToPercentage(container);\n\n  if (x < geometry.x - marginX) return false;\n  if (y < geometry.y - marginY) return false;\n  if (x > geometry.x + marginX) return false;\n  if (y > geometry.y + marginY) return false;\n\n  return true;\n}\n\nexport function area(_geometry: IGeometry, container: IContainer) {\n  const { marginX, marginY } = marginToPercentage(container);\n\n  return marginX * marginY;\n}\n\nexport const methods: ISelectorMethods = {\n  onClick(\n    annotation: IAnnotation | undefined,\n    e: TouchEvent | MouseEvent,\n    options: SelectorMethodsOptions\n  ): IAnnotation | undefined {\n    if (!annotation?.geometry) {\n      return {\n        ...annotation,\n        selection: {\n          mode: SelectionMode.Final,\n        },\n        geometry: {\n          ...getCoordPercentage(e)!,\n          width: 0,\n          height: 0,\n          type: TYPE,\n        },\n        data: {\n          id: options.idFunction(),\n        },\n      };\n    }\n    return;\n  },\n};\n\nconst PointSelector: ISelector = {\n  TYPE,\n  intersects,\n  area,\n  methods,\n};\n\nexport default PointSelector;\n","import {\n  AllowedShape,\n  IGeometry,\n  IPoint,\n  ISelector,\n  ISelectorMethods,\n} from '../types/index';\nimport { createSelectorMethods } from './SelectorUtils';\n\nconst square = (n: number) => Math.pow(n, 2);\n\nexport const TYPE = AllowedShape.Oval;\n\nexport function intersects({ x, y }: IPoint, geometry: IGeometry) {\n  const rx = geometry.width / 2;\n  const ry = geometry.height / 2;\n  const h = geometry.x + rx;\n  const k = geometry.y + ry;\n\n  const value = square(x - h) / square(rx) + square(y - k) / square(ry);\n\n  return value <= 1;\n}\n\nexport function area(geometry: IGeometry) {\n  const rx = geometry.width / 2;\n  const ry = geometry.height / 2;\n\n  return Math.PI * rx * ry;\n}\n\nexport const methods: ISelectorMethods = createSelectorMethods(TYPE);\n\nconst OvalSelector: ISelector = {\n  TYPE,\n  intersects,\n  area,\n  methods,\n};\n\nexport default OvalSelector;\n","import React from 'react';\nimport styled from 'styled-components';\nimport { IAnnotation } from '../../types/index';\n\nconst Container = styled.div`\n  background: white;\n  border-radius: 2px;\n  box-shadow: 0 1px 5px 0 rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14),\n    0 3px 1px -2px rgba(0, 0, 0, 0.12);\n  padding: 8px 16px;\n  margin-top: 8px;\n  margin-left: 8px;\n  z-index: 2;\n`;\n\nexport interface ContentProps {\n  style?: {};\n  className?: '';\n  annotation: IAnnotation;\n}\n\nexport default function Content(props: ContentProps) {\n  const { geometry } = props.annotation;\n  if (!geometry) return null;\n\n  return (\n    <Container\n      style={{\n        position: 'absolute',\n        left: `${geometry.x}%`,\n        top: `${geometry.y + geometry.height}%`,\n        ...props.style,\n      }}\n      className={props.className}\n    >\n      {props.annotation.data && props.annotation.data.text}\n    </Container>\n  );\n}\n","import styled from 'styled-components';\n\nexport default styled.div`\n  background: rgba(0, 0, 0, 0.4);\n  border-radius: 5px;\n  bottom: 4px;\n  color: white;\n  font-size: 12px;\n  font-weight: bold;\n  opacity: 0;\n  padding: 10px;\n  pointer-events: none;\n  position: absolute;\n  right: 4px;\n  transition: opacity 0.21s ease-in-out;\n  user-select: none;\n`;\n","import React, { ComponentType, useCallback, useState } from 'react';\nimport { EditorMode, ShapeProps, WrappedShapeProps } from '../../types';\n\nexport const withShapeWrapper = (\n  DecoratedShape: ComponentType<ShapeProps>\n): ComponentType<\n  Omit<WrappedShapeProps, 'isMouseOver' | 'onMouseEnter' | 'onMouseLeave'>\n> => {\n  const WrappedComponent = (props: WrappedShapeProps) => {\n    const {\n      annotation,\n      children,\n      editorMode,\n      isInSelectionMode,\n      renderContent,\n      selectedAnnotation,\n      style,\n    } = props;\n    const [mouseHovered, setMouseHovered] = useState<boolean>(false);\n\n    const shouldShowContent =\n      editorMode === EditorMode.AnnotateWithText &&\n      mouseHovered &&\n      renderContent;\n\n    const reactContentElement =\n      shouldShowContent && props.annotation.data.text && renderContent\n        ? renderContent(props)\n        : null;\n\n    const onMouseEnter = useCallback(() => setMouseHovered(true), []);\n    const onMouseLeave = useCallback(() => setMouseHovered(false), []);\n    const onClick = () => {\n      if (props.onAnnotationClick) {\n        props.onAnnotationClick(annotation);\n      }\n    };\n\n    const shapeStyle = isInSelectionMode\n      ? { zIndex: 0, ...(style || {}) }\n      : style;\n\n    return (\n      <div onClick={onClick}>\n        <DecoratedShape\n          annotation={annotation}\n          children={children}\n          editorMode={editorMode}\n          isMouseOver={mouseHovered}\n          isSelected={\n            !!selectedAnnotation &&\n            annotation.data.id === selectedAnnotation.data.id\n          }\n          onMouseEnter={onMouseEnter}\n          onMouseLeave={onMouseLeave}\n          style={shapeStyle}\n        />\n\n        {reactContentElement}\n      </div>\n    );\n  };\n\n  return WrappedComponent;\n};\n","import React from 'react';\nimport { withShapeWrapper } from './withShapeWrapper';\nimport styled from 'styled-components';\nimport { EditorMode, ShapeProps } from '../../types/index';\n\nconst Container = styled.div`\n  border-radius: 100%;\n  box-shadow: 0 0 2px 2px white inset;\n  box-sizing: border-box;\n  transition: box-shadow 0.21s ease-in-out;\n  z-index: ${({ isReadOnly }: { isReadOnly: boolean }) =>\n    `${isReadOnly ? 0 : 1};`};\n  cursor: ${({ isReadOnly }: { isReadOnly: boolean }) =>\n    isReadOnly ? 'auto;' : 'pointer;'};\n`;\n\nfunction Oval(props: ShapeProps) {\n  const {\n    annotation: { geometry },\n    children,\n    editorMode,\n    isMouseOver,\n    isSelected,\n    onMouseEnter,\n    onMouseLeave,\n  } = props;\n  const isReadOnly = editorMode === EditorMode.ReadOnly;\n\n  if (!geometry) return null;\n\n  const isActive = !isReadOnly && (isMouseOver || isSelected);\n\n  return (\n    <Container\n      isReadOnly={isReadOnly}\n      onMouseEnter={onMouseEnter}\n      onMouseLeave={onMouseLeave}\n      style={{\n        position: 'absolute',\n        left: `${geometry.x}%`,\n        top: `${geometry.y}%`,\n        height: `${geometry.height}%`,\n        width: `${geometry.width}%`,\n        border: isActive ? 'solid 1px black' : 'dashed 2px black',\n        boxShadow: isActive ? '0 0 1px 1px black inset' : '',\n        backgroundColor: isActive\n          ? 'rgba(128, 128, 128, 0.3)'\n          : 'rgba(128, 128, 128, 0.05)',\n        ...(props.style || {}),\n      }}\n    >\n      {children || null}\n    </Container>\n  );\n}\n\nexport default React.memo(withShapeWrapper(Oval));\n","import React from 'react';\nimport styled from 'styled-components';\nimport { EditorMode, ShapeProps } from '../../types/index';\nimport { withShapeWrapper } from './withShapeWrapper';\n\nconst Container = styled.div`\n  border-radius: 50%;\n  box-sizing: border-box;\n  // prettier-ignore\n  box-shadow: \n          0 0 0 1px rgba(0, 0, 0, 0.3),\n          0 0 0 2px rgba(0, 0, 0, 0.2),\n          0 5px 4px rgba(0, 0, 0, 0.4);\n  height: 16px;\n  position: absolute;\n  transform: translate3d(-50%, -50%, 0);\n  width: 16px;\n  z-index: ${({ isReadOnly }: { isReadOnly: boolean }) =>\n    `${isReadOnly ? 0 : 1};`};\n  cursor: ${({ isReadOnly }: { isReadOnly: boolean }) =>\n    isReadOnly ? 'auto;' : 'pointer;'};\n`;\n\nfunction Point(props: ShapeProps) {\n  const {\n    annotation: { geometry },\n    children,\n    editorMode,\n    isMouseOver,\n    isSelected,\n    onMouseEnter,\n    onMouseLeave,\n  } = props;\n  const isReadOnly = editorMode === EditorMode.ReadOnly;\n\n  if (!geometry) return null;\n\n  const isActive = !isReadOnly && (isMouseOver || isSelected);\n\n  return (\n    <Container\n      isReadOnly={isReadOnly}\n      onMouseEnter={onMouseEnter}\n      onMouseLeave={onMouseLeave}\n      style={{\n        top: `${geometry.y}%`,\n        left: `${geometry.x}%`,\n        border: isActive ? 'solid 3px grey' : 'solid 3px white',\n        ...(props.style || {}),\n      }}\n    >\n      {children || null}\n    </Container>\n  );\n}\n\nexport default React.memo(withShapeWrapper(Point));\n","import React from 'react';\nimport styled from 'styled-components';\nimport { EditorMode, ShapeProps } from '../../types/index';\nimport { withShapeWrapper } from './withShapeWrapper';\n\nconst Container = styled.div`\n  box-shadow: 0 0 2px 2px white inset;\n  box-sizing: border-box;\n  transition: box-shadow 0.21s ease-in-out;\n  z-index: ${({ isReadOnly }: { isReadOnly: boolean }) =>\n    `${isReadOnly ? 0 : 1};`};\n  cursor: ${({ isReadOnly }: { isReadOnly: boolean }) =>\n    isReadOnly ? 'auto;' : 'pointer;'};\n`;\n\nfunction Rectangle(props: ShapeProps) {\n  const {\n    annotation: { geometry },\n    children,\n    editorMode,\n    isMouseOver,\n    isSelected,\n    onMouseEnter,\n    onMouseLeave,\n  } = props;\n  const isReadOnly = editorMode === EditorMode.ReadOnly;\n\n  if (!geometry) return null;\n\n  const isActive = !isReadOnly && (isMouseOver || isSelected);\n\n  return (\n    <Container\n      isReadOnly={isReadOnly}\n      onMouseEnter={onMouseEnter}\n      onMouseLeave={onMouseLeave}\n      style={{\n        position: 'absolute',\n        left: `${geometry.x}%`,\n        top: `${geometry.y}%`,\n        height: `${geometry.height}%`,\n        width: `${geometry.width}%`,\n        border: isActive ? 'solid 1px black' : 'dashed 2px black',\n        boxShadow: isActive ? '0 0 1px 1px black inset' : '',\n        backgroundColor: isActive\n          ? 'rgba(128, 128, 128, 0.3)'\n          : 'rgba(128, 128, 128, 0.05)',\n        ...(props.style || {}),\n      }}\n    >\n      {children || null}\n    </Container>\n  );\n}\n\nexport default React.memo(withShapeWrapper(Rectangle));\n","import Editor from './Editor';\nimport React, { ReactElement } from 'react';\n\nimport { OvalSelector, PointSelector, RectangleSelector } from '../selectors';\nimport {\n  AnnotationProps,\n  ContentProps,\n  EditorMode,\n  RenderEditorProps,\n  RenderShapeProps,\n  RenderOverlayProps,\n} from './../types/index';\nimport Content from './Content';\nimport Overlay from './Overlay';\nimport Oval from './Shapes/Oval';\nimport Point from './Shapes/Point';\nimport Rectangle from './Shapes/Rectangle';\n\nconst defaultProps: AnnotationProps = {\n  src: '',\n\n  annotations: [],\n  editorMode: EditorMode.AnnotateWithText,\n\n  idFunction: () => Math.random().toString(),\n\n  onAnnotationsUpdate: () => {},\n  onAnnotationClick: () => {},\n  onSelectedAnnotationUpdate: () => {},\n\n  overlayOptions: {\n    displayOverlay: true,\n  },\n\n  renderEditor: ({ annotation, onSubmit }: RenderEditorProps) => (\n    <Editor annotation={annotation} onSubmit={onSubmit} />\n  ),\n\n  renderShape: (props: RenderShapeProps): ReactElement | null => {\n    const { annotation } = props;\n    switch (annotation.geometry.type) {\n      case RectangleSelector.TYPE:\n        return <Rectangle {...props} />;\n      case PointSelector.TYPE:\n        return <Point {...props} />;\n      case OvalSelector.TYPE:\n        return <Oval {...props} />;\n      default:\n        return null;\n    }\n  },\n\n  renderContent: ({ key, annotation }: ContentProps) => (\n    <Content key={key} annotation={annotation} />\n  ),\n\n  renderOverlay: ({\n    annotations,\n    selectorType,\n    overlayText,\n  }: RenderOverlayProps): ReactElement => {\n    if (overlayText) {\n      return <Overlay>{overlayText}</Overlay>;\n    }\n    if (annotations.length === 0) {\n      switch (selectorType) {\n        case PointSelector.TYPE:\n          return <Overlay>Click to Annotate</Overlay>;\n        default:\n          return <Overlay>Click and Drag to Annotate</Overlay>;\n      }\n    } else {\n      return <Overlay>Select the annotation for additional options</Overlay>;\n    }\n  },\n\n  selectors: [RectangleSelector, PointSelector, OvalSelector],\n\n  allowedShapes: [\n    RectangleSelector.TYPE,\n    OvalSelector.TYPE,\n    PointSelector.TYPE,\n  ],\n\n  toolBarOptions: {\n    showDeleteOption: true,\n    showToolBar: true,\n    renderSelectedAnnotationIcons: () => null,\n    renderToolbarIcons: () => null,\n  },\n};\nexport default defaultProps;\n","import React, { useRef } from 'react';\nimport styled from 'styled-components';\n\nconst Img = styled.img`\n  display: block;\n  width: 100%;\n`;\n\ninterface ImageProps {\n  alt?: string;\n  draggable?: boolean;\n  src: string;\n  style?: object;\n}\n\nexport default function Image(props: ImageProps) {\n  const imageRef = useRef<HTMLImageElement>(null);\n\n  const { alt, draggable, src, style } = props;\n  return (\n    <Img\n      alt={alt}\n      draggable={draggable}\n      ref={imageRef}\n      src={src}\n      style={style}\n    />\n  );\n}\n","import React, { ReactElement } from 'react';\nimport styled from 'styled-components';\nimport { AllowedShape, RenderToolbarProps } from '../../types/index';\nimport BackSvg from './icons/arrowLeft.svg';\nimport CircleSvg from './icons/circle.svg';\nimport PointSvg from './icons/point.svg';\nimport SquareSvg from './icons/square.svg';\nimport TrashSvg from './icons/trash.svg';\n\nconst ToolbarDiv = styled.div`\n  border: 1px solid #ccc;\n  background-color: #efefef;\n  width: 100%;\n  display: flex;\n`;\n\nconst StyledIcon = styled.a`\n  border-right: 1px solid #ccc;\n  width: 40px;\n  height: 40px;\n  background-repeat: no-repeat;\n  background-position: center;\n  cursor: pointer;\n  background-color: ${({ isSelected }: { isSelected: boolean }) =>\n    isSelected ? '#ccc' : '#efefef'};\n`;\n\nconst CircleIcon = styled(StyledIcon)`\n  background-image: url(${CircleSvg});\n`;\nconst PointIcon = styled(StyledIcon)`\n  background-image: url(${PointSvg});\n`;\nconst SquareIcon = styled(StyledIcon)`\n  background-image: url(${SquareSvg});\n`;\nconst BackIcon = styled(StyledIcon)`\n  background-image: url(${BackSvg});\n`;\nconst TrashIcon = styled(StyledIcon)`\n  background-image: url(${TrashSvg});\n`;\n\nexport default function ToolBar({\n  allowedShapes,\n  deleteAnnotation,\n  options,\n  selectedAnnotation,\n  selectedSelectorType,\n  setSelectedSelectorType,\n  unSelectSelectedAnnotation,\n}: RenderToolbarProps): ReactElement | null {\n  return options.showToolBar ? (\n    <ToolbarDiv>\n      {selectedAnnotation ? (\n        <>\n          <BackIcon\n            isSelected={false}\n            onClick={() => unSelectSelectedAnnotation(selectedAnnotation)}\n          />\n          {options.renderSelectedAnnotationIcons?.({\n            annotation: selectedAnnotation,\n            unSelectAnnotation: () =>\n              unSelectSelectedAnnotation(selectedAnnotation),\n          })}\n          <TrashIcon\n            isSelected={false}\n            onClick={() => deleteAnnotation(selectedAnnotation)}\n          />\n        </>\n      ) : (\n        <>\n          {allowedShapes.includes(AllowedShape.Rectangle) ? (\n            <SquareIcon\n              isSelected={selectedSelectorType === AllowedShape.Rectangle}\n              onClick={() => setSelectedSelectorType(AllowedShape.Rectangle)}\n            />\n          ) : null}\n          {allowedShapes.includes(AllowedShape.Oval) ? (\n            <CircleIcon\n              isSelected={selectedSelectorType === AllowedShape.Oval}\n              onClick={() => setSelectedSelectorType(AllowedShape.Oval)}\n            />\n          ) : null}\n          {allowedShapes.includes(AllowedShape.Point) ? (\n            <PointIcon\n              isSelected={selectedSelectorType === AllowedShape.Point}\n              onClick={() => setSelectedSelectorType(AllowedShape.Point)}\n            />\n          ) : null}\n        </>\n      )}\n    </ToolbarDiv>\n  ) : null;\n}\n","import React, { Component, ComponentType, MouseEvent, TouchEvent } from 'react';\nimport { getOffsetCoordPercentage } from './offsetCoordinates';\n\nexport interface ElementDetails {\n  innerRef: (el: HTMLImageElement) => void;\n  onMouseMove: (e: MouseEvent) => void;\n  onMouseLeave: (e: MouseEvent) => void;\n  onTouchMove: (e: TouchEvent) => void;\n  onTouchLeave: (e: TouchEvent) => void;\n  x: number;\n  y: number;\n}\n\nexport interface WithRelativeMousePosProps {\n  [key: string]: ElementDetails;\n}\nconst withRelativeMousePos =\n  <T extends {}>(key = 'relativeMousePos') =>\n  (DecoratedComponent: ComponentType<T>): ComponentType<T> => {\n    class WithRelativeMousePos extends Component<T> {\n      state = { x: 0, y: 0 };\n      container: HTMLImageElement | undefined;\n\n      innerRef = (el: HTMLImageElement) => {\n        this.container = el;\n      };\n\n      onMouseMove = (e: MouseEvent) => {\n        const xystate = getOffsetCoordPercentage(e);\n        this.setState(xystate);\n      };\n      onTouchMove = (e: TouchEvent) => {\n        if (e.targetTouches.length === 1) {\n          const touch = e.targetTouches[0];\n\n          const offsetX =\n            touch.pageX -\n            (this.container?.offsetParent as HTMLDivElement)?.offsetLeft;\n          const offsetY =\n            touch.pageY -\n            (this.container?.offsetParent as HTMLDivElement)?.offsetTop;\n\n          this.setState({\n            x: (offsetX / this.container!.width) * 100,\n            y: (offsetY / this.container!.height) * 100,\n          });\n        }\n      };\n\n      onMouseLeave = (_e: MouseEvent) => {\n        this.setState({ x: null, y: null });\n      };\n      onTouchLeave = (_e: TouchEvent) => {\n        this.setState({ x: null, y: null });\n      };\n\n      render() {\n        const props = {\n          innerRef: this.innerRef,\n          onMouseMove: this.onMouseMove,\n          onMouseLeave: this.onMouseLeave,\n          onTouchMove: this.onTouchMove,\n          onTouchLeave: this.onTouchLeave,\n          x: this.state.x,\n          y: this.state.y,\n        };\n        const hocProps: WithRelativeMousePosProps = {\n          [key]: props,\n        };\n\n        return <DecoratedComponent {...this.props} {...hocProps} />;\n      }\n    }\n\n    // WithRelativeMousePos.displayName = `withRelativeMousePos(${DecoratedComponent.displayName})`;\n\n    return WithRelativeMousePos;\n  };\n\nexport default withRelativeMousePos;\n","import React, {\n  ComponentType,\n  MouseEvent,\n  TouchEvent,\n  useCallback,\n  useEffect,\n  useState,\n} from 'react';\nimport styled from 'styled-components';\nimport {\n  AnnotationProps,\n  EditorMode,\n  IAnnotation,\n  ISelector,\n  SelectionMode,\n} from '../types/index';\nimport compose from '../utils/compose';\nimport useHandleEscapeEvent from '../utils/useHandleEscapeEvent';\nimport withRelativeMousePos, {\n  WithRelativeMousePosProps,\n} from '../utils/withRelativeMousePos';\n\nimport defaultProps from './defaultProps';\nimport ImageElement from './Image';\nimport Overlay from './Overlay';\nimport ToolBar from './ToolBar/ToolBar';\n\nconst Container = styled.div`\n  clear: both;\n  position: relative;\n  width: 100%;\n\n  &:hover ${Overlay} {\n    opacity: 1;\n  }\n`;\n\nconst ItemsDiv = styled.div`\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n`;\n\nconst ReadOnlyDiv = styled.div`\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n`;\n\nexport type AnnotationPropsOptional = {\n  [K in keyof AnnotationProps]?: AnnotationProps[K]; // so that it retains the types\n};\n\nfunction Annotation(options: AnnotationProps & WithRelativeMousePosProps) {\n  const props: AnnotationProps = {\n    ...defaultProps,\n    ...options,\n  };\n\n  const allowTouch = false;\n  const {\n    allowedShapes,\n\n    alt,\n    className,\n\n    editorMode,\n\n    idFunction,\n\n    onSelectedAnnotationUpdate,\n    onAnnotationClick: onAnnotationClickProp,\n\n    overlayOptions,\n\n    renderShape,\n    renderEditor,\n    renderOverlay,\n\n    style,\n    src,\n\n    toolBarOptions,\n  } = props;\n\n  const [selectedSelectorType, setSelectedSelectorType] = useState<string>(\n    props.allowedShapes[0]\n  );\n\n  // This annotation is set when adding a new annotation. The state is cleared after annotation is added\n  const [selectedAnnotation, setSelectedAnnotation] = useState<\n    IAnnotation | undefined\n  >();\n\n  // This annotation is set when adding a new annotation. The state is cleared after annotation is added\n  const [tmpAnnotation, setTmpAnnotation] = useState<IAnnotation | undefined>();\n\n  const [annotations, setAnnotations] = useState<IAnnotation[]>(\n    options.annotations\n  );\n\n  useEffect(() => {\n    setAnnotations(options.annotations);\n  }, [options.annotations]);\n\n  const [showEditor, setShowEditor] = useState<boolean>(false);\n\n  const targetRef = React.createRef<any>();\n\n  const addTargetTouchEventListeners = () => {\n    // Safari does not recognize touch-action CSS property,\n    // so we need to call preventDefault ourselves to stop touch from scrolling\n    // Event handlers must be set via ref to enable e.preventDefault()\n    // https://github.com/facebook/react/issues/9809\n\n    targetRef.current.ontouchstart = onTouchStart;\n    targetRef.current.ontouchend = onTouchEnd;\n    targetRef.current.ontouchmove = onTargetTouchMove;\n    targetRef.current.ontouchcancel = onTargetTouchLeave;\n  };\n  const removeTargetTouchEventListeners = () => {\n    targetRef.current.ontouchstart = undefined;\n    targetRef.current.ontouchend = undefined;\n    targetRef.current.ontouchmove = undefined;\n    targetRef.current.ontouchcancel = undefined;\n  };\n\n  const isInEditMode =\n    editorMode !== EditorMode.ReadOnly &&\n    editorMode !== EditorMode.ReadOnlyWithSelection;\n\n  useEffect(() => {\n    if (isInEditMode) {\n      if (allowTouch) {\n        addTargetTouchEventListeners();\n      } else {\n        removeTargetTouchEventListeners();\n      }\n    }\n  });\n\n  const getSelectorByType = (type: string): ISelector => {\n    return props.selectors.find((s) => s.TYPE === type)!;\n  };\n\n  const onTargetMouseMove = (e: MouseEvent) => {\n    options.relativeMousePos.onMouseMove(e);\n    onMouseMove(e);\n  };\n  const onTargetTouchMove = (e: TouchEvent) => {\n    options.relativeMousePos.onTouchMove(e);\n    onTouchMove(e);\n  };\n\n  const onTargetMouseLeave = (e: MouseEvent) => {\n    options.relativeMousePos.onMouseLeave(e);\n  };\n  const onTargetTouchLeave = (e: TouchEvent) => {\n    options.relativeMousePos.onTouchLeave(e);\n  };\n\n  const onMouseUp = (e: MouseEvent) => callSelectorMethod('onMouseUp', e);\n  const onMouseDown = (e: MouseEvent) => callSelectorMethod('onMouseDown', e);\n  const onMouseMove = (e: MouseEvent) => callSelectorMethod('onMouseMove', e);\n  const onTouchStart = (e: TouchEvent) => callSelectorMethod('onTouchStart', e);\n  const onTouchEnd = (e: TouchEvent) => callSelectorMethod('onTouchEnd', e);\n  const onTouchMove = (e: TouchEvent) => callSelectorMethod('onTouchMove', e);\n\n  const onClick = (e: MouseEvent) => {\n    unselectSelectedAnnotation();\n\n    callSelectorMethod('onClick', e);\n  };\n\n  const onAnnotationFinal = (annotation: IAnnotation) => {\n    const newAnnotationArray = [...annotations, annotation];\n    setAnnotations(newAnnotationArray);\n    options.onAnnotationsUpdate(newAnnotationArray);\n    setTmpAnnotation(undefined);\n  };\n\n  const callSelectorMethod = (\n    methodName:\n      | 'onMouseUp'\n      | 'onMouseDown'\n      | 'onMouseMove'\n      | 'onTouchStart'\n      | 'onTouchEnd'\n      | 'onTouchMove'\n      | 'onClick',\n    e: MouseEvent | TouchEvent\n  ) => {\n    const { editorMode } = props;\n\n    if (!!options[methodName]) {\n      (options[methodName] as any)(e);\n    } else {\n      const selector = getSelectorByType(selectedSelectorType);\n      const selectorMethod = selector.methods[methodName];\n      if (selectorMethod) {\n        const value: IAnnotation | undefined = selectorMethod(\n          tmpAnnotation,\n          e,\n          { editorMode, idFunction }\n        );\n\n        setTmpAnnotation(value);\n        switch (value?.selection?.mode) {\n          case SelectionMode.Final:\n            onAnnotationFinal(value);\n            setShowEditor(true);\n            break;\n          case SelectionMode.Editing:\n            setShowEditor(true);\n            break;\n          default:\n            setTmpAnnotation(value);\n            setShowEditor(true);\n            break;\n        }\n      }\n    }\n  };\n\n  const deleteAnnotation = (annotationToDelete: IAnnotation) => {\n    const filtered = annotations.filter(\n      (annotation) => annotation.data.id !== annotationToDelete.data.id\n    );\n    const newAnnotationsValue = [...filtered];\n    setAnnotations(newAnnotationsValue);\n    setSelectedAnnotation(undefined);\n    props.onAnnotationsUpdate(newAnnotationsValue);\n  };\n\n  const unselectSelectedAnnotation = () => {\n    if (selectedAnnotation) {\n      setSelectedAnnotation(undefined);\n      onSelectedAnnotationUpdate(selectedAnnotation, false);\n    }\n  };\n\n  const onAnnotationClick = useCallback(\n    (annotation: IAnnotation) => {\n      setSelectedAnnotation(annotation);\n      onSelectedAnnotationUpdate(annotation, true);\n      onAnnotationClickProp(annotation);\n    },\n    [onAnnotationClickProp, onSelectedAnnotationUpdate]\n  );\n\n  useHandleEscapeEvent(unselectSelectedAnnotation, selectedAnnotation);\n  return (\n    <div className={className}>\n      {isInEditMode && (\n        <ToolBar\n          allowedShapes={allowedShapes}\n          deleteAnnotation={deleteAnnotation}\n          options={toolBarOptions}\n          selectedAnnotation={selectedAnnotation}\n          selectedSelectorType={selectedSelectorType}\n          setSelectedSelectorType={setSelectedSelectorType}\n          unSelectSelectedAnnotation={unselectSelectedAnnotation}\n        />\n      )}\n      <Container\n        style={{\n          ...props.style,\n          touchAction: allowTouch ? 'pinch-zoom' : 'auto',\n        }}\n        onMouseLeave={onTargetMouseLeave}\n        onTouchCancel={onTargetTouchLeave}\n      >\n        <ImageElement style={style} alt={alt} src={src} draggable={false} />\n        <ItemsDiv>\n          {annotations.map((annotation) =>\n            renderShape({\n              annotation: annotation,\n              editorMode: props.editorMode,\n              isInSelectionMode: !!tmpAnnotation,\n              key: annotation.data.id,\n              renderContent: props.renderContent,\n              onAnnotationClick: onAnnotationClick,\n              selectedAnnotation: selectedAnnotation,\n            })\n          )}\n          {tmpAnnotation?.geometry &&\n            renderShape({\n              annotation: tmpAnnotation,\n              editorMode: props.editorMode,\n              isInSelectionMode: !!tmpAnnotation,\n              key: tmpAnnotation.data.id,\n              renderContent: props.renderContent,\n              onAnnotationClick: onAnnotationClick,\n            })}\n        </ItemsDiv>\n        {isInEditMode ? (\n          <ItemsDiv\n            onClick={onClick}\n            onMouseUp={onMouseUp}\n            onMouseDown={onMouseDown}\n            onMouseMove={onTargetMouseMove}\n            ref={targetRef}\n          />\n        ) : (\n          <ReadOnlyDiv onClick={unselectSelectedAnnotation} />\n        )}\n        {isInEditMode &&\n          overlayOptions?.displayOverlay &&\n          renderOverlay({\n            annotations,\n            overlayText: overlayOptions?.overlayText,\n            selectorType: selectedSelectorType,\n          })}\n        {showEditor &&\n          tmpAnnotation &&\n          tmpAnnotation.selection?.mode === SelectionMode.Editing &&\n          renderEditor({\n            annotation: tmpAnnotation,\n            onSubmit: onAnnotationFinal,\n          })}\n        <div>{props.children}</div>\n      </Container>\n    </div>\n  );\n}\n\nconst WrappedAnnotation: ComponentType<AnnotationPropsOptional> = compose(\n  withRelativeMousePos()\n)(Annotation);\n\nexport default WrappedAnnotation;\n","import { useEffect } from 'react';\nimport { IAnnotation } from '../types/index';\n\nexport default function useHandleEscapeEvent(\n  unselectSelectedAnnotation: () => void,\n  selectedItem?: IAnnotation\n) {\n  useEffect(() => {\n    function handleKeyDown(event: KeyboardEvent) {\n      if (event.key === 'Escape') {\n        unselectSelectedAnnotation();\n      }\n    }\n\n    // Bind the event listener\n    document.addEventListener('keydown', handleKeyDown);\n    return () => {\n      // Unbind the event listener on clean up\n      document.removeEventListener('keydown', handleKeyDown);\n    };\n  }, [selectedItem, unselectSelectedAnnotation]);\n}\n"],"names":["EditorMode","SelectionMode","AllowedShape","compose","funcs","length","arg","reduce","a","b","getMouseRelativeCoordinates","e","rect","currentTarget","getBoundingClientRect","x","clientX","width","y","clientY","height","clamp","i","Math","max","min","getCoordPercentage","isTouchEvent","isValidTouchEvent","isTouchMoveEvent","preventDefault","touch","targetTouches","boundingRect","offsetY","pageY","top","window","scrollY","pageX","left","getTouchRelativeCoordinates","undefined","type","Inner","styled","div","Button","TextEditor","props","React","Fragment","placeholder","onFocus","onBlur","onChange","value","onClick","onSubmit","fadeInScale","keyframes","Container","Editor","geometry","annotation","useState","text","setText","className","style","position","target","data","pointerDown","options","selection","mode","New","anchorX","anchorY","id","idFunction","pointerUp","_e","editorMode","Selecting","AnnotateOnly","Final","Editing","pointerMove","newX","newY","abs","createSelectorMethods","onMouseDown","onMouseUp","onMouseMove","onTouchStart","onTouchEnd","onTouchMove","TYPE","Rectangle","RectangleSelector","intersects","area","methods","marginToPercentage","container","marginX","marginY","Point","PointSelector","_geometry","square","n","pow","Oval","OvalSelector","rx","ry","k","PI","Content","withShapeWrapper","DecoratedShape","children","isInSelectionMode","renderContent","selectedAnnotation","mouseHovered","setMouseHovered","reactContentElement","AnnotateWithText","onMouseEnter","useCallback","onMouseLeave","shapeStyle","zIndex","onAnnotationClick","isMouseOver","isSelected","isReadOnly","ReadOnly","isActive","border","boxShadow","backgroundColor","memo","defaultProps","src","annotations","random","toString","onAnnotationsUpdate","onSelectedAnnotationUpdate","overlayOptions","displayOverlay","renderEditor","renderShape","key","renderOverlay","selectorType","overlayText","Overlay","selectors","allowedShapes","toolBarOptions","showDeleteOption","showToolBar","renderSelectedAnnotationIcons","renderToolbarIcons","Img","img","Image","imageRef","useRef","alt","draggable","ref","ToolbarDiv","StyledIcon","CircleIcon","PointIcon","SquareIcon","BackIcon","TrashIcon","ToolBar","deleteAnnotation","selectedSelectorType","setSelectedSelectorType","unSelectSelectedAnnotation","unSelectAnnotation","includes","ItemsDiv","ReadOnlyDiv","Annotation","onAnnotationClickProp","setSelectedAnnotation","tmpAnnotation","setTmpAnnotation","setAnnotations","useEffect","showEditor","setShowEditor","targetRef","createRef","isInEditMode","ReadOnlyWithSelection","current","ontouchstart","ontouchend","ontouchmove","ontouchcancel","onAnnotationFinal","newAnnotationArray","callSelectorMethod","methodName","selectorMethod","find","s","_value$selection","unselectSelectedAnnotation","selectedItem","handleKeyDown","event","document","addEventListener","removeEventListener","useHandleEscapeEvent","annotationToDelete","filtered","filter","newAnnotationsValue","touchAction","relativeMousePos","onTouchCancel","onTouchLeave","ImageElement","map","DecoratedComponent","el","xystate","getOffsetCoordPercentage","setState","offsetX","_this","_this$container","offsetParent","_this$container$offse","offsetLeft","_this$container2","_this$container2$offs","offsetTop","render","hocProps","innerRef","this","state","Component"],"mappings":"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"}